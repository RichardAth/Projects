[HELP]
This a big integer calculator and a factorisation program. Start by entering
an expression which will be evaluated and the resulting value will normally 
be factorised. e.g

    2^131-1                            <<< you enter expression to be evaluated

     = 2722 258935 367507 707706 996859 454145 691647 (40 digits)  <<< result
     = 263 * 10 350794 431055 162386 718619 237468 234569          <<< factors  

The sum of divisors, number of divisors, möbius  & totient are also displayed; 
they are easy to calculate once the factors are known.
Any number can be expressed as the sum of 4 or fewer squares. Usually there are
many ways of doing this. One way is displayed.

Numeric values can be stored in variables which must have names beginning with $ or _
and contain only letters, digits $ or _ characters. Names are not case-sensitive. 
Assign values to variables using the assignment operator =
e.g.
$p= n(200)
$x = 2^$p-1

the result will be:
$P = 211
$X = 3291009114642412084309938365114701009965471731267159726697218047

In addition to entering expressions as described above, some commands can be entered.
These commands include the HELP command.

You can get further help by entering "HELP <topic>" selecting from the following topics:
expression  function  yafu  msieve  other  test  loop   background qmes  pari

or enter "HELP <function name>" for help on a specific function.

[EXPRESSION]
Expressions are composed of numbers, operators, functions and user variables.

Numbers can be entered in decimal, or in hexadecimal preceded by 0x or 0X.
Functions consist of <function_name>(<parameter> [,<parameter> ...])
Most functions have a fixed number of parameters, but the GCD and LCM functions
can have 2 or more parameters. Function parameters are themselves expressions,
which can contain nested function calls.

Expressions use the following operators:
^ or **   : exponentiation (the exponent must be greater than or equal to zero,
            and less than 2^31, result must not exceed 30,000 digits)
*         : multiplication (result must not exceed 30,000 digits)
/         : integer division (rounded towards zero if necessary)
%         : modulus (remainder from integer division, has the same sign as the 
            dividend)
+         : addition
-         : subtraction
SHL or << : Shift left the number of bits specified on the right operand. The
            resulting value must not exceed 30,000 digits
SHR or >> : Shift right the number of bits specified on the right operand.
<, >, <=, >= for comparisons.  The operators return zero for false and -1 for true.
==, != for equality. The operators return zero for false and -1 for true.
NOT, AND, XOR, OR  for bitwise operations.
n!        : factorial (n must be greater than or equal to zero). n must be < 5983
n!..!     : multi-factorial (n must be greater than or equal to zero, the result
            must not exceed 20,000 digits).
p#        : primorial (product of all primes less or equal than p).
            p must not exceed 46340 so that the result does not exceed 20,000 digits.
C         : binomial coefficient. nCk = n!/(k!*(n-k)!) but is more efficient.
            k must be < 2^31.
=         : assignment operator. The left operand of the assignment must be a user 
            variable.

#(primorial) !(factorial) and !...!(multi-factorial) operators have the highest priority, 
above NOT and unary -, which are above ^ (exponentiation)
The normal rules for operator precedence and use of brackets to over-ride the 
default order of evaluation apply.

User variables can be created and used like multiple memories in a pocket calculator.
Numeric values can be stored in these variables which must have names beginning with 
$ or _ and contain only letters, digits $ or _ characters. Names are not case-sensitive. 
Assign values to variables using the assignment operator = 
Assignment statements are also expressions which return the value to the right of the =
operator.

[FUNCTION]
B(n)            : Previous probable prime before n
F(n)            : Fibonacci number Fn (maximum value of n is 95700, mimimum is -95700,
                  so that the result does not exceed 20,000 digits)
L(n)            : Lucas number Ln = F(n-1) + F(n+1). (maximum value of n is 95700,
                  so that the result does not exceed 20,000 digits)
N(n)            : Next probable prime after n
P(n)            : Unrestricted Partition Number (number of decompositions of n, 
                  into sums of integers without regard to order)
                  (maximum value of n is 10^6) 
Pi(n)           : Number of primes <= n (maximum value of n is 10^13)
Gcd(m, n ...)   : Greatest common divisor of m, n ...
Lcm(m, n ...)   : Least common multiple of m, n ...
Abs(n)          : absolute value of n 
Modinv(m, n)    : inverse of m modulo n, only valid when gcd(m, n) = 1.
Modpow(m, n, r) : finds m^n modulo r Equivalent to m^n%r but more efficient.
Totient(n)      : finds the number of positive integers less than n which are 
                  relatively prime to n.
Carmichael(n)   : λ(n) of a positive integer n is the smallest positive integer 
                  m such that a^m ≡ 1   (mod n) for every integer a between 1 
                  and n that is coprime to n. Also known as the reduced totient
                  function.
Dedekind(n)     : Dedekind psi function. product of p^(e-1)(p+1) where p=prime 
                  factor and e=exponent
IsPrime(n)      : returns zero if n is composite, -1 if it is a probable prime.
BPSW(n)         : Baillie-PSW primality test. It returns zero if n is composite, 
                  1 for probable prime, 2 for definite prime. 
                  considered to be 100% reliable for numbers up to 10000 digits
APRCL(n)        : Adleman-Pomerance-Rumely primality test. If the number is > 6021 
                  digits it reverts to the BPSW test. Returns zero if n is 
                  composite, 1 for probable prime (only if BPSW used), 2 for a
                  definite prime. WARNING: very slow for large numbers e.g. 20s 
                  for 400 digits.
ISPOWERFUL(n)   : returns -1 if n is a powerful number, 0 if not. A number is
                  powerful if and only if every prime factor has an exponent 2 or 
                  more. Equivalently, a powerful number is the product of a 
                  square and a cube.
ISSQUAREFREE(n) : returns -1 if n is square-free, 0 if not.
ISFUNDAMENTAL(n): returns -1 if n is a Fundamental Discriminant, otherwise 0.
ISPOLYGONAL(n, s): returns -1 if n is a polygonal number, otherwise 0. s 
                  specifies the number of sides to the polygon; s = 3 for triangular,
                  4 for square, 5 for pentagonal, etc. Must have n >= 1, s >= 3.
NumDivs(n)      : Number of positive divisors of n either prime or composite.
SumDivs(n, x)   : Sum of xth power of positive divisors of n, either prime or 
                  composite. if x = 0 the result is the same as the NumDivs function.
Divisors(n)     : Get list of divisors of n, either prime or composite. The value
                  returned is the number of divisors (same as numdivs)
NumDigits(n, r) : Number of digits of n in base r.
SumDigits(n, r) : Sum of digits of n in base r.
RevDigits(n, r) : finds the value obtained by writing backwards the digits of n 
                  in base r.
Sqrt(n)         : square root of n
Nroot(n, r)     : rth root of n e.g.r=3 for cube root. r must be < 2^31
NumFact(n)      : number of distinct prime factors of n.
MinFact(n)      : minimum prime factor of n.
MaxFact(n)      : maximum prime factor of n
LLT(n)          : perform Lucas-Lehmer test. Return 0 if 2^n-1 is composite, 
                  1 if prime. n must be >0 and < 2^31.
FactConcat(m,n) : Concatenates the prime factors of n (base 10) according to the mode m
                  mode    Order of factors    Repeated factors
                  0       Ascending           No
                  1       Descending          No
                  2       Ascending           Yes
                  3       Descending          Yes
R2(n)           : Number of ways n can be expressed as the sum of x² + y².  
                  (order and sign of x and y are significant)
R2P(n)          : Number of ways n can be expressed as the sum of x² + y².  
                  (ignoring order and signs) 
                  e.g. 325 = 18²+1 = 17²+6² = 10²+15² so R2P(325) = 3
                  25 = 5²+0 = 3²+4² so R2P(25) = 2
R3(n)           : Number of ways n can be expressed as the sum of x² + y² + z². 
                  (order and sign of x, y and z are significant) N.B. very slow
                  for large numbers e.g. 2 min for a 12 digit number.
R3H(n)          : same as R3 but calculated using Hurwitz-Kronecker class number.
                  (much faster) Currently restricted to n < 10^35.
R4(n)           : Number of ways n can be expressed as the sum of w² + x² + y² + z². 
                  (order and sign of w, x, y and z are significant)
HCLASS(n)       : Hurwitz-Kronecker class number *12. Currently restricted to
                  n < 10^35. The true HCLASS is not always an integer, but 
                  multiplying by 12 always yields an integer.
CLASSNO(n)      : class number. This is only defined if n ≡ 0 or 1 mod 4 and n is
                  not a perfect square. For +ve n, n must be < 730,000,000 to avoid
                  pari stack overflow.
TAU(x)          : Ramanujan's tau function
STIRLING(n, k, f): if f = 1 return the Stirling number of the first kind s(n,k), 
                  if f = 2, return the Stirling number of the second kind S(n,k).
                  n and k must be less than 2^63.
LE(a,p)         : Legendre value for (a/p). Only defined if p is an odd prime.
                  The result is zero when a is a multiple of p, otherwise it is 
                  one if there is a solution of x² ≡ a (mod p) and it is -1 when 
                  the congruence has no solution.
JA(a,p)         : Jacobi value for (a/p). Extension of Legendre to all odd values of p.
KR(a,p)         : Kronecker value for (a/p); an extension of the Jacobi value to
                  all values of p
ISPOW(n)        : returns -1 if n is a perfect power, otherwise 0
MODSQRT(a, p)   : returns r such that r² ≡ a (mod p). If no solution exists an error
                  is reported. Generally there is more than 1 solution in the range 0 
                  to p-1, but only the smallest positive solution is returned.
PRIMROOT(a)     : returns smallest primitive root of a if there is one. Primitive 
                  roots exists if a is 2, 4, an odd prime power, or twice an odd 
                  prime power.
INVTOT(x)       : finds values of n such that totient(n) = x. There may be no such 
                  value, or many values. x is limited to 10^15 because large values 
                  use too much memory and could hang the PC.
POPCNT(x)       : for x >= 0, counts the number of 1-bits, also known as the
                  Hamming weight.
HAMDIST(x, y)   : counts the number of bits which differ beween x and y. x and
                  y must have the same sign.
GF(x)           : Gauss Factorial of x, defined as the product of all positive 
                  numbers < x  that are relatively prime to x. If GF(x) would 
                  exceed 30,000 digits an error is generated. 
QUADDISC(x)     : Discriminant of quadratic field Q(sqrt(x)). 
EULERFRAC(x)    : Euler number E(x). Undefined for x < 0. If x is odd E(x) is zero.
                  x must be <= 9022 to limit the result to 30,000 digits. 
PISANO(n)       : Pisano period for n. the largest factor of n must be < 2^31, 
                  because for large factors of n the calculation might take too 
                  long.

[OTHER]
other commands: 
SET  : opens a dialog box that has equivalents to the YAFU, MSIEVE, PARI, X, 
       D, F, V, S and E commands. This dialog box also has a control to set the 
       'group size'. This controls the number of digits displayed in each group 
       for large numbers. Use 0 for no space between groups.
X    : hexadecimal o/p, 
D    : decimal o/p
F n  : control factorisation, 
       n = 0 : just evaluate expression, no factorisation
       n = 1 : evaluate expression, factorise resulting value, but don't do no. of
               divisors, etc.
       n = 2 : evaluate expression, factorise resulting value, then get no. of 
               divisors, sum of divisors, totient, möbius, sum of squares.
       initial setting is n = 2.
S    : switch to Spanish, 
E    : switch to English
V n  : Set 'verbosity' to n. n=0 is the default which minimises output.
       n = 1 turns on many messages that show more of what is happening internally.
       n = 2 turns on even more messages.
PRINT  Print the names and values of any user variables.
LIST   Print all stored expressions.
HELP   (this command)
QMES   Enter Quadratic Modular Equation Solver
EXIT   Terminates the calculator program. 

[YAFU]
The YAFU command controls factorisation using YAFU:

   YAFU ON   Turns on factorisation using YAFU (and turns Msieve off)
   YAFU OFF  Turns off factorisation using YAFU (revert to built-in ECM and SIQS)
   YAFU PATH Displays the path used when starting YAFU. The path is saved in the 
             .ini file so only needs to be set once. It will also verify that the 
             yafu-X64.exe file exists.
   YAFU PATH SET will display a windows explorer style window where you can 
             navigate to the correct folder then click on the yafu exe file. The 
             new path to the YAFU file will then be saved in the 
             BigIntCalculator.ini file.
   YAFU OUT  Displays or changes path & file name for YAFU output file. The path
             is saved in the .ini file so only needs to be set once.
   YAFU PLAN <name> 
             where <name> is NONE, NOECM, LIGHT, NORMAL, or DEEP. These 
             correspond to the -plan options documented in YAFU's docfile.txt 
             file. The default is NORMAL. This is a convenient way to control 
             the amount of testing using ECM before switching to SIQS or NFS.
   YAFU TIDY Deletes a number of files left behind by YAFU. If never deleted, 
             the log and json files seem to grow larger indefinately.

   YAFU INI  will check whether the YAFU.ini file exist. If it does it is read 
             and any ggnfs_dir parameter is found. If ggnfs_dir is found the 
             path that it contains is checked by checking for the existence of 
             the gnfs-lasieve4iXXe.exe files, where XX is between 11 and 16. Note 
             that YAFU INI requires the YAFU path to already be set correctly (by 
             YAFU PATH or otherwise).

   YAFU INI I allows the ggnfs_dir parameter to be altered or created. It will 
             display a windows explorer style window where you can navigate to 
             the correct folder then click on any file. The new path to the ggnfs 
             files will then be saved in the ggnfs_dir parameter of the YAFU.ini file.

YAFU is on by default but can be turned off by the "YAFU OFF" command and turned 
back on by the YAFU ON command (which also turns Msieve off). 

Equivalents to all YAFU commands are available in the dialog box entered via the 
'SET' command.
[MSIEVE]
Msieve is off by default but can be turned on by the "MSIEVE ON" command (which 
also turns YAFU off) and turned back off by the MSIEVE OFF command. The path to 
access Msieve should be changed to whatever is appropriate.

MSIEVE PATH will display the current path and verify that the msieve.exe 
file exists.
MSIEVE PATH SET will display a windows explorer style window where you can 
navigate to the correct folder then click on the Msieve exe file. The new path 
to the Msieve file will then be saved in the BigIntCalculator.ini file.

MSIEVE LOG will display the full path for the log file (which contains the result
of the factorisation)
MSIEVE LOG SET will display a windows explorer style window where you can 
navigate to the correct folder and select the log file if present, or type in the
the file name if not already present.

MSIEVE E ON turns on the E option in Msieve for 'deep' ECM
MSIEVE E off turns off the E option

MSIEVE N ON turns on the N option to use the Number Field sieve for factorisation.
MSIEVE N OFF turns off the N option.

Equivalents to all MSIEVE commands are available in the dialog box entered via the 
'SET' command.
[TEST]
There are a number of built-in test commands. In all tests the results are
checked for correctness and a summary of the factorisation results is printed
after the tests are completed:

TEST    1st tests most of the calculator functions, then factorises a series of
        numbers. The numbers are chosen to test for various special cases as well
        as normal factorisation. This test is good for regression testing.

TEST 2  test factorisation using pseudo-random numbers of a specified size.
        Command format is TEST 2 [num1[,num2[,num3]]] where 
        num1 is the number of tests (default value is 2),  
        num2 is the size of the numbers to be factored in bits (default = 48 bits). 
        If num3 = 0 the numbers to be factored are random numbers that can
        contain any number of factors. (0 is the default value)
        If num3 > 0 the numbers to be factored consist of 2 approximately same- 
        sized 'strong' prime factors,   
        If num3 = 0 or 1 a fixed 'seed' for the random number generator is used. 
        If num3 = 2 a truly random seed value is used. 
        If num3 > 2 the value of num3 is used as the 'seed' value. 

        If the value for num2 is the same and num3 ≠ 2 in two TEST 2 commands
         the same sequence of numbers to be factored is generated. each time.  
        This is useful for benchmarking factorisation.

TEST 3  Tests for the built-in bigintegers. These are based on DA's biginteger 
        functions but made into a C++ class with arithmetic , shift, compare 
        operators, etc implemented. However the built-in bigintegers are now 
        only used in the the built-in ECM & SIQS, which themselves are only 
        used for numbers up to 59 digits, so this test is not normally included.

TEST 4  test factorisation of mersenne numbers. See https://en.wikipedia.org/wiki/Mersenne_prime
        this test will take over an hour.

TEST 5  tests using only YAFU for factorisation. Note that these tests bypass the
        trial division etc normally used and rely on YAFU for all the factorisation.

TEST 6  tests using only Msieve for factorisation. Factorise selected Mersenne numbers.

TEST 7  tests the Lucas-Lehmer function. Format is TEST 7 [num]. All primes <= num are
        tested to see whether 2^p-1 is prime or not. The default value for num is
        12000.   Sample output:

            test 7 87000
            18:47:15 2^2 -1 is prime ***
            18:47:15 2^3 -1 is prime ***
            18:47:15 2^5 -1 is prime ***
            18:47:15 2^7 -1 is prime ***
            18:47:15 2^13 -1 is prime ***
            18:47:15 2^17 -1 is prime ***
            18:47:15 2^19 -1 is prime ***
            18:47:15 2^31 -1 is prime ***
            18:47:15 2^61 -1 is prime ***
            18:47:15 2^89 -1 is prime ***
            18:47:15 2^107 -1 is prime ***
            18:47:15 2^127 -1 is prime ***
            18:47:15 2^521 -1 is prime ***
            18:47:15 2^607 -1 is prime ***
            18:47:16 2^1279 -1 is prime ***
            18:47:16 2^2203 -1 is prime ***
            18:47:16 2^2281 -1 is prime ***
            18:47:17 2^3217 -1 is prime ***
            18:47:18 2^4253 -1 is prime ***
            18:47:18 2^4423 -1 is prime ***
            18:47:53 2^9689 -1 is prime ***
            18:47:56 2^9941 -1 is prime ***
            18:48:15 2^11213 -1 is prime ***
            18:55:42 2^19937 -1 is prime ***
            18:57:54 2^21701 -1 is prime ***
            19:00:14 2^23209 -1 is prime ***
            20:33:19 2^44497 -1 is prime ***
            08:18:34 2^86243 -1 is prime ***
            Found 28 Mersenne primes  out of 8450 numbers tested
            2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 
            3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
            0.33% primes found by llt
            99.67% composites found by llt
            08:40:38 test 7 completed time used =  13h 53 min 23.314sec

        This has found the 1st 28 Mersenne primes in less than 14 hours. The 
        last of these was originally found in 1982 using a mult-million $ Cray
        supercomputer. Talk about standing on the shoulders of giants!

TEST 8  test error handling
TEST 9  test modular square root (use "TEST 9 H" for more info).
TEST 10 [p1[,p2]]    test quadratic modular equation solver, where p1 is the 
        number of tests (default = 20) and p2 is the number size in bits.
TEST 11 [p1[,p2[,p3]]] Test R3 and R3h functions. p1 = mumber of tests,
        p2 = size of numbers to be tested, 
        If p3 = 0 or 1 a fixed 'seed' for the random number generator is used. 
        If p3 = 2 a truly random seed value is used. 
        If p3 > 2 the value of num3 is used as the 'seed' value. 

TEST 12 [p1[,p2[,p3]]] Test R4 function. p1, p2 and p3 are used in the 
        same way as for TEST 11

Test example:

enter expression to be processed, or HELP, or EXIT
TEST 2 5
Use default 48 for number size in bits
 
 <******** output from indivdial tests omitted *****************>

10:48:34 All tests completed. Time used = 0.172 seconds
Test Num Size   time      Unique Factors Total Factors     2nd Fac tdv prh leh crm pm1 ecm siq pwr yaf msv
   1       14  0:00:00.02             4          4            4      3   0   0   0   0   0   0   0   0   0
   2       15  0:00:00.05             4          4            3      3   0   0   0   0   0   0   0   0   0
   3       15  0:00:00.03             3          3            5      2   0   0   0   0   0   0   0   0   0
   4       15  0:00:00.03             2          2            5      1   0   0   0   0   0   0   0   0   0
   5       14  0:00:00.03             5          6            4      4   0   0   0   0   0   0   0   0   0


   note: The 'Size' column gives the size in decimal digits of the number to be
   factored. The 'time' column gives the time required for each factorisation to 
   one-hundredth of a second.
   The '2nd Fac' column gives the size of the 2nd largest factor, which correlates 
   much more closely with time required than the 'Size' does.
   tdv: the number of factors found by trial division
   prh: the number of factors found using Pollard-Rho algorithm
   leh: the number of factors found using Lehman's algorithm
   crm: the number of factors found using an algorith designed to factor Carmichael numbers
   pm1: the number of factors found for a number which is a perfect power + or - 1
   ecm: the number of factors found using the elliptic curve method
   siq: the number of factors found using the SIQS method
   pwr: the number of facors found because the number was recognised to be a perfect power
   yaf: the number of factors found using YAFU
   msv: the number of factors found using Msieve

[AYUDA]
Puedes ingresar expresiones que usen los siguientes operadores y paréntesis:
^ o ** para exponenciación(el exponente debe ser mayor o igual que cero).
* para multiplicación
/ para división entera
% para el resto de la división entera
+ para suma
- para resta
SHL o <<: Desplazar a la izquierda la cantidad de bits indicada en el operando derecho.
SHR o >>: Desplazar a la derecha la cantidad de bits indicada en el operando derecho.
<, ==, >, <=, >=, != para comparaciones.Los operadores devuelven cero si es falso 
        y - 1 si es verdadero.
AND, OR, XOR, NOT para lógica binaria.
n!   : factorial(n debe ser mayor o igual que cero).
p#   : primorial(producto de todos los primos menores o iguales a p).
B(n) : Número probablemente primo anterior a n
F(n) : Número de Fibonacci Fn
L(n) : Número de Lucas Ln = F(n-1) + F(n+1)
N(n) : Número probablemente primo posterior a n
P(n) : particiones irrestrictas(cantidad de descomposiciones de n en sumas de números 
       enteros sin tener en cuenta e orden).
Gcd(m, n)       : Máximo común divisor de estos dos números enteros.
Modinv(m, n)    : inverso de m modulo n, sólo válido cuando gcd(m, n) = 1.
Modpow(m, n, r) : halla m^n módulo r.
Totient(n)      : cantidad de enteros positivos menores que n coprimos con n.
Ja(m,n)         : obtiene el símbolo de Jacobi de m y n. Cuando el segundo argumento
                  es primo, el resultado es cero si m es múltiplo de n, es uno si hay
                  una solución a x² = m (mód n) y es igual a -1 cuando la congruencia
                  mencionada no tiene soluciones.
IsPrime(n)      : returna cero si n no es un primo probable y - 1 si lo es.
NumDivs(n)      : cantidad de divisores positivos de n primos o compuestos.
SumDivs(n)      : suma de divisores positivos de n primos o compuestos.
NumDigits(n, r) : cantidad de dígitos de n en base r.
SumDigits(n, r) : suma de dígitos de n en base r.
RevDigits(n, r) : halla el valor que se obtiene escribiendo para atrás los dígitos 
                  de n en base r.
Sqrt(n)         : parte entera de la raíz cuadrada del argumento
NumFact(n)      : cantidad de factores primos distintos de n. Ejemplo: NumFact(28) = 2 
                  porque los factores primos son 2 y 7
MinFact(n)      : mínimo factor primo de n. Ejemplo: MinFact(28) = 2 porque los 
                  factores primos son 2 y 7.
MaxFact(n)      : máximo factor primo de n. Ejemplo: MaxFact(28) = 7 porque los 
                  factores primos son 2 y 7.

[BACKGROUND]
INTRODUCTION

This is a calculator and factorisation program based on Dario Alpern's program.
See https://www.alpertron.com.ar/ECM.HTM

It factorises numbers or numeric expressions using fast algorithms ECM and SIQS.
ECM = Lenstra elliptic-curve factorization
see https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization
SIQS = Self-initializing quadratic sieve
see http://www.mersennewiki.org/index.php/Self-Initializing_Quadratic_Sieve
or https://en.wikipedia.org/wiki/Quadratic_sieve

HISTORY

the program was converted from browser-based to a console window. The advantage
is that it is somewhat faster, and the calculator part contains some additional 
functions. The disadvantage is that you have to download and build it. In order 
to do that you need GMP or MPIR multi-precision library and the Boost multi-precision 
library.

the following changes were made:

C++ rather than C

The calculator part was extensively rewritten to use GMP/MPIR extended precision
and the Boost multiprecision library. Wherever possible GMP functions were used
instead of DAs version of bigIntegers.

Standard arithmetic operators for extended precision values use the Boost library,  
which implements them using GMP/MPIR functions.

FACTORIZATION

The built-in factoriser is essentially DAs program, with an interface function 
that converts GMP/MPIR extended precision numbers to DAs BigIntegers and vice 
versa. The progress messages it produces have been modified to work with a 
console window instead of a Web Browser.

A feature was added to allow use of Msieve as an alternative to the original ECM & SIQS
factorisation. My conclusion was that for larger numbers (> about 60 digits) Msieve
is usually significantly faster, provided that the -e option is used with Msieve.
The -e option causes greater use of ECM within Msieve. The default in mseive is 
to use ECM only for factors < 15 digits. 

Msieve is off by default but can be turned on by the "MSIEVE ON" command (which 
also turns YAFU off) and turned back off by the MSIEVE OFF command. The path to 
access Msieve should be changed to whatever is appropriate.

Additionally, the option to use YAFU (Yet Another Factorisation Utility) instead of 
Msieve or the built-in ECM and SIQS has been added. The conclusion is that for 
numbers over about 60 digits YAFU is generally significantly faster than Msieve 
but for larger numbers > about 95 digits it relies on ggnfs.

YAFU is on by default but can be turned off by the "YAFU OFF" command and turned 
back on by the YAFU ON command (which also turns Msieve off). The default path to 
access YAFU should be changed to whatever is appropriate.

As mentioned above ECM and SIQS are used for factorisation.

At all stages a factor list is maintained that contains all known factors, whether
prime or not, that have not yet been split into smaller factors. Initially the
factor list just contains the number to be factorised. Whenever a new factor is found,
existing factors that are multiples of that factor are split into two factors. If
this process creates equal factors they are merged. 

Primes up to 393203 (33335 primes) are used in trial division.

Step 1: if number to factor is > than the the square of the largest prime to be 
used in trial division, check if the number is a perfect power +/- 1 and if so 
attempt to factorise it. This step may return factors that are not prime factors.

Step 2: Try to factorise each factor (there may already be more than 1) by trial division 
using a list of primes. If a residue after trial division is found that is: 
    less than the cube of the largest prime in the trial division prime list, 
    and has no factors in that list, and the residue is not prime 
then the residue can only have two prime factors. In this case factorise it using 
Pollard's Rho algorithm. 

Step 3: For each factor that is not already known to be prime:
A. If the factor is a perfect power replace it with the number which is the root 
   and adjust the the factor's exponent accordingly. Although such numbers are  
   rare this is necessary because SIQS and ECM do not work for numbers which are
   perfect powers.
B. Test whether the number is prime: 
   If it is a Carmichael number factorise it using a specific algorithm. 
   If it is prime mark it as such. 
   Otherwise either:
      factorise it using built-in ECM, SIQS and Lehman algorithms. This method is 
      alway used for numbers less than 2^192 (58 digits). built-in SIQS is only 
      used for numbers between 30 and 95 digits.
  OR
      factorise it using Msieve. Using modified Msieve that makes more use of
      elliptic curve factorisation than the standard version (even with the e option)
      does, this is nearly always faster for larger numbers that would use SIQS 
      for factorisation.
   OR
      factorise it using YAFU
 
sample timing:
2^311-1 (94 digits)
YAFU on             10 min 
MSIEVE on           30 min
builtin ECM & SIQS  57 min

When a number > 2^64 is factorised the result is saved in a 'cache file'. If the
same number is to be factorised again, the result from the cache file is found
and reused rather than repeating the factorisation. This use of the cache file
overrides the YAFU and Msieve factorisation settings.

Saving Calculator Settings

Bigint Calculator uses a .ini file to save setup parameter values, rather than 
using the registry.

Sample file:
    %file originally created on 26/07/2020 at 19:53:52
    yafu-path=C:\Users\admin99\Downloads\yafu-master\bin\x64\Release
    yafu-prog=yafu-x64.exe
    msieve-path=C:\Users\admin99\Source\Repos\RichardAth\Projects\bin\x64\Release
    msieve-prog=msieve.exe
    helpfile=C:\Users\admin99\Source\Repos\RichardAth\Projects\BigIntCalculator\docfile.txt
    paripath=c:/Program Files (x86)/Pari64-2-13-2/libpari.dll
    endsound=c:/Windows/Media/Alarm09.wav
    attsound=c:/Windows/Media/chimes.wav

Lines beginning with % are comments.
yafu-path    Path to access YAFU program
yafu-prog    name of YAFU executable file
msieve-path  Path to access Msieve program
msieve-prog  name of Msieve executable file
helpfile     path and name of help file containing all the text displayed by the 
             HELP command
paripath     path to access the libpari.dll file
endsound     path and file name for 'end' sound played when an operation
             that lasts more than 10 seconds is completed.
attsound     path and file name for sound played when prompting for input.

[LOOP]
Simple lists of expressions can be executed repeatedly using the REPEAT n
command e.g.
$p=n($p)
REPEAT 1000

will generate 1000 primes. (If $p has no value assigned initially it defaults 
to 0). Obviously REPEAT is pointless unless some variable used in the loop
is assigned a new value within the loop.

The LOOP command is used if some initial expressions are not to be repeated
e.g.

$p=151
LOOP
$p=n($p)
REPEAT 1000

An alternative to the simple REPEAT is the IF command e.g.
$p=151
LOOP
$p=n($p)
IF ($p < 10000) REPEAT

format is IF (expression) REPEAT 
          or IF (expression) STOP 
          or IF (expression) THEN (expression, expression, ...) [ELSE (expression, ...)]
          the [ELSE (expression ...)] part is optional

The IF command is processed as follows:
1.  The expression in brackets after IF is evaluated. 
2.  If the value is not zero the action specified after THEN is performed, 
    otherwise the ELSE action is taken. The action can be REPEAT  which goes 
    back to the start of the loop, or STOP which terminates the loop, or a series 
    of expressions separated by commas.
3   If the value is zero any expressions following the ELSE are evaluated.
  
    Remember that assignment statements are also expressions, so mini-programs
    can be created. However, nested IFs are not possible.

    The loop can contain many IF commands.

the LIST command will output all the saved expressions. Expressions entered
before the last LOOP command are not shown.

Note that invalid expressions and commands other than IF are not saved, and there 
is no way to edit saved expressions. It is only possible to delete them all using 
the LOOP command and start again.

[QMES]

The Quadratic modular equation solver is entered by the QMES command.

This can solve equations of the form ax² + bx + c ≡ 0 (mod n) where the integer 
unknown x is in the range 0 ≤ x < n. In particular, it can find modular square 
roots by setting a = -1, b = 0, c = number whose root we want to find and 
n = modulus.
When prompted, enter values for a, b, c and n. These can be numbers or expressions.
The calculator accepts numbers of up to 10000 digits but notice that the modulus n 
has to be factored (some large numbers cannot be factored in a reasonable amount of 
time). The same factorisation process as described elsewhere is used.

This is actually Dario Alpern's solver, converted from a web page to a console 
program. 

[PRINT]

Russsian
ЁЂЃЄЅФЧЫЮ

Greek
ΆΌΈΏΣπσψόϒΩϕΠ

accents etc
«áéíóú  àèìòù âêîôû õ ã ç ºª» § €$#£ ¿?

others
¦§¨©ª«¬­­®¯°±²³´¹º»¼½¾ ❶❿

Emoticons
❤💜☮☪😀🤣😅😊😍😗😗☺🤩😐🙄😥😯🥴🎈🎆🎇🎉✨🧨

[PARI]

PARI/GP is a widely used computer algebra system designed for fast computations 
in number theory (factorizations, algebraic number theory, elliptic curves...), 
but also contains a large number of other useful functions.

A number of functions in this calculator have ben implemented using libpari.
These functions are: R3H, HCLASS, CLASSNO, TAU, STIRLING, QUADDISC, EULERFRAC. 
The first time one of these functions is called the linkage to libpari is set up. 
If the linking process fails the program aborts. (If these functions are never 
called the linkage is not set up, and the libpari file need not exist)

The name of the libpari file is obtained from the paripath parameter in the 
BigIntCalculator.ini file, e.g. 
    paripath=c:/Program Files (x86)/Pari64-2-13-2/libpari.dll

Factorisation using PARI is turned on by "PARI ON" command, off by "PARI OFF"
The "PARI CLOSE" command frees the memory used by the pari stack. 
"PARI PATH" displays the current path to the libpari.dll file, and 
"PARI PATH SET" can change the path to access the .dll file.

To install libpari go to https://pari.math.u-bordeaux.fr/download.html

[B]
B(n)      Previous probable prime < n

[F]
F(n)  Fibonacci number Fn (maximum value of n is 95700, mimimum is -95700,
      so that the result does not exceed 20,000 digits.) The Fibonacci
      sequence starts with 0,1,1,2,3. Each number after 0, 1 is the 
      sum of the preceding two. Negafibonacci numbers are supported.

F n   control factorisation, 
       n = 0 : just evaluate expression, no factorisation
       n = 1 : evaluate expression, factorise resulting value, but don't do no. of
               divisors, etc.
       n = 2 : evaluate expression, factorise resulting value, then get no. of 
               divisors, sum of divisors, totient, möbius, sum of squares.
       initial setting is n = 2.
[L]
L(n)      Lucas number L(n) = F(n-1) + F(n+1). (maximum value of n is 95700,
          so that the result does not exceed 20,000 digits)
[N]
N(n)      Next probable prime after n
[P]
P(n)      Unrestricted Partition Number (number of decompositions of n, 
          into sums of integers without regard to order)
          (maximum value of n is 10^6) 
[Pi]
Pi(n)     Number of primes <= n (maximum value of n is 10^13)
[GCD]
Gcd(m, n ...)   Greatest common divisor of m, n ...
[LCM]
Lcm(m, n ...)   Least common multiple of m, n ...
[ABS]
Abs(n)    absolute value of n 
[MODINV]
Modinv(m, n)    inverse of m modulo n, only valid when gcd(m, n) = 1.
[MODPOW]
Modpow(m, n, r) finds m^n modulo r Equivalent to m^n%r but more efficient.
[TOTIENT]
Totient(n)    finds the number of positive integers less than n which are 
              relatively prime to n.
[CARMICHAEL]
Carmichael(n)   λ(n) of a positive integer n is the smallest positive integer 
                m such that a^m ≡ 1   (mod n) for every integer a between 1 
                and n that is coprime to n. Also known as the reduced totient
                function.
[DEDEKIND]
Dedekind(n)     Dedekind psi function. product of p^(e-1)(p+1) where p=prime 
                factor of n and e=exponent of that factor. 
[ISPRIME]
IsPrime(n)  returns zero if n is composite, -1 if it is a probable prime.
[BPSW]
BPSW(n)   Baillie-PSW primality test. It returns zero if n is composite, 
          1 for probable prime, 2 for definite prime. 
          considered to be 100% reliable for numbers up to 10000 digits
[APRCL]
APRCL(n)  Adleman-Pomerance-Rumely primality test. If the number is > 6021 
          digits it reverts to the BPSW test. Returns zero if n is 
          composite, 1 for probable prime (only if BPSW used), 2 for a
          definite prime. Unlike other, more efficient algorithms for this 
          purpose, it avoids the use of random numbers, so it is a 
          deterministic primality test. WARNING: very slow for large 
          numbers e.g. 20s for 400 digits
[ISPOWERFUL]
ISPOWERFUL(n)   returns -1 if n is a powerful number, 0 if not. A number is
                powerful if and only if every prime factor has an exponent 2 or 
                more. Equivalently, a powerful number is the product of a 
                square and a cube.
[ISSQUAREFREE]
ISSQUAREFREE(n) returns -1 if n is square-free, 0 if not.
[ISFUNDAMENTAL]
ISFUNDAMENTAL(n) returns -1 if n is a Fundamental Discriminant, otherwise 0.
[ISPOLYGONAL]
ISPOLYGONAL(n, s) returns -1 if n is a polygonal number, otherwise 0. s 
                  specifies the number of sides to the polygon; s = 3 for triangular,
                  4 for square, 5 for pentagonal, etc. Must have n >= 1, s >= 3.
[NUMDIVS]
NumDivs(n)  Number of positive divisors of n either prime or composite.
[SUMDIVS]
SumDivs(n, x)   Sum of xth power of positive divisors of n, either prime or 
                composite. if x = 0 the result is the same as the NumDivs function.
[DIVISORS]
Divisors(n)     Get list of divisors of n, either prime or composite. The value
                returned is the number of divisors (same as numdivs). If this
                is the outermost or only function in the expression the list of 
                divisors is displayed. If there are more than 33333333 divisors
                the list is not produced.
[NUMDIGITS]
NumDigits(n, r) Number of digits of n in base r.
[SUMDIGITS]
SumDigits(n, r) Sum of digits of n in base r.
[REVDIGITS]
RevDigits(n, r) finds the value obtained by writing backwards the digits of n 
                in base r.
[SQRT]
Sqrt(n)   square root of n, rounded down to nearest integer.
[NROOT]
Nroot(n, r)  rth root of n e.g.r=3 for cube root, rounded down to nearest 
             integer. r must be < 2^31. 
[NUMFACT]
NumFact(n)   number of distinct prime factors of n.
[MINFACT]
MinFact(n)   minimum prime factor of n.
[MAXFACT]
MaxFact(n)   maximum prime factor of n
[LLT]
LLT(n)      perform Lucas-Lehmer test. Return 0 if 2^n-1 is composite, 
            1 if prime. n must be >0 and <= 2^31.
[FACTCONCAT]
FactConcat(m,n) Concatenates the prime factors of n (base 10) according to the mode m
                  mode    Order of factors    Repeated factors
                  0       Ascending           No
                  1       Descending          No
                  2       Ascending           Yes
                  3       Descending          Yes
[R2]
R2(n)       Number of ways n can be expressed as the sum of x² + y².  
            (order and sign of x and y are significant)
[R2P]
R2P(n)      Number of ways n can be expressed as the sum of x² + y².  
            (ignoring order and signs) 
            e.g. 325 = 18²+1 = 17²+6² = 10²+15² so R2P(325) = 3
            25 = 5²+0 = 3²+4² so R2P(25) = 2
[R3]
R3(n)       Number of ways n can be expressed as the sum of x² + y² + z². 
            (order and sign of x, y and z are significant) N.B. very slow
            for large numbers e.g. 2 min for a 12 digit number.
[R3H]
R3H(n)      same as R3 but calculated using Hurwitz-Kronecker class number.
            (much faster) Currently restricted to n < 10^35.
[R4]
R4(n)       Number of ways n can be expressed as the sum of w² + x² + y² + z². 
            (order and sign of w, x, y and z are significant)
[HCLASS]
HCLASS(n)   Hurwitz-Kronecker class number *12. Currently restricted to
            n < 10^35. The true HCLASS is not always an integer, but 
            multiplying by 12 always yields an integer.
[CLASSNO]
CLASSNO(n)  class number. This is only defined if n ≡ 0 or 1 mod 4 and n is
            not a perfect square. For +ve n, n must be < 730,000,000 to avoid
            pari stack overflow.
[TAU]
TAU(x)      Ramanujan's tau function
[STIRLING]
STIRLING(n, k, f) if f = 1 return the Stirling number of the first kind s(n,k), 
                  if f = 2, return the Stirling number of the second kind S(n,k).
                  n and k must be less than 2^63.
[LE]
LE(a,p)     Legendre value for (a/p). Only defined if p is an odd prime.
            The result is zero when a is a multiple of p, otherwise it is 
            one if there is a solution of x² ≡ a (mod p) and it is -1 when 
            the congruence has no solution.
[JA]
JA(a,p)     Jacobi value for (a/p). Extension of Legendre to all odd values of p.
[KR]
KR(a,p)     Kronecker value for (a/p); an extension of the Jacobi value to
            all values of p
[ISPOW]
ISPOW(n)    returns -1 if n is a perfect power, otherwise 0
[MODSQRT]
MODSQRT(a, p)   returns r such that r² ≡ a (mod p). If no solution exists an error
                is reported. Generally there is more than 1 solution in the range 0 
                to p-1, but only the smallest positive solution is returned.
[PRIMROOT]
PRIMROOT(a) returns smallest primitive root of a if there is one. Primitive 
            roots exists if a is 2, 4, an odd prime power, or twice an odd 
            prime power.
[INVTOT]
INVTOT(x)   finds n such that totient(n) = x. There may be no such value, or 
            many values. x is limited to 10^15 because large values use too 
            much memory and could hang the PC.
[POPCNT]
POPCNT(x)   for x >= 0, counts the number of 1-bits, also known as the
            Hamming weight.
[HAMDIST]
HAMDIST(x, y  counts the number of bits which differ beween x and y. x and
              y must have the same sign.
[GF]
GF(x)       Gauss Factorial of x, defined as the product of all positive 
            numbers < x  that are relatively prime to x. If GF(x) would excceed
            30,000 digits an error is generated. 
[QUADDISC]
QUADDISC(x)  Discriminant of quadratic field Q(sqrt(x)). 
[EULERFRAC]
EULERFRAC(x)  Euler number E(x). Undefined for x < 0. If x is odd E(x) is zero.
              x must be <= 9022 to limit the result to 30,000 digits. 
[PISANO]
PISANO(n)    Pisano period for n. the largest factor of n must be < 2^31, 
             because for large factors of n the calculation might take too 
             long.
[X]
X    switch to hexadecimal o/p.
[D]
D    switch to decimal o/p
[S]
S    switch to Spanish
[E]
E    switch to English
[V]
V n  Set 'verbosity' to n. n=0 is the default which minimises output.
       n = 1 turns on many messages that show more of what is happening internally.
       n = 2 turns on even more messages.