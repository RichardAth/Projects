[HELP]
This a big integer calculator and a factorisation program. Start by entering
an expression which will be evaluated and the resulting value will normally 
be factorised. e.g

    2^131-1                            <<< you enter expression to be evaluated

     = 2722 258935 367507 707706 996859 454145 691647 (40 digits)  <<< result
     = 263 * 10 350794 431055 162386 718619 237468 234569          <<< factors  

The sum of divisors, number of divisors, möbius  & totient are also displayed; 
they are easy to calculate once the factors are known.
Any number can be expressed as the sum of 4 or fewer squares. Usually there are
many ways of doing this. One way is displayed.

Numeric values can be stored in variables which must have names beginning with $ or _
and contain only letters, digits $ or _ characters. Names are not case-sensitive. 
Assign values to variables using the assignment operator =
e.g.
$p= n(200)
$x = 2^$p-1

the result will be:
$P = 211
$X = 3291009114642412084309938365114701009965471731267159726697218047

You can get help on the following topics by entering "HELP <topic>";
expression  function  yafu  msieve  other  test  loop   background

[EXPRESSION]
You can enter expressions that use the following operators, also functions 
and parentheses:
^ or **   : exponentiation (the exponent must be greater than or equal to zero).
*         : multiplication
/         : integer division
%         : modulus (remainder from integer division)
+         : addition
-         : subtraction
SHL or << : Shift left the number of bits specified on the right operand.
SHR or >> : Shift right the number of bits specified on the right operand.
<, >, <=, >= for comparisons.  The operators return zero for false and -1 for true.
==, != for equality. The operators return zero for false and -1 for true.
NOT, AND, XOR, OR  for bitwise operations.
n!        : factorial (n must be greater than or equal to zero).
n!..!     : multi-factorial (n must be greater than or equal to zero).
p#        : primorial (product of all primes less or equal than p).
C         : binomial coefficient. nCk = n!/(k!*(n-k)!) but is more efficient

#(primorial) !(factorial) and !...!(multi-factorial) operators have the highest priority, 
above NOT and unary -, which are above ^ (exponentiation)
The normal rules for operator precedence and use of brackets to over-ride the 
default order of evaluation apply.

for a list of functions enter HELP FUNCTION

[FUNCTION]
B(n)            : Previous probable prime before n
F(n)            : Fibonacci number Fn
L(n)            : Lucas number Ln = F(n-1) + F(n+1)
N(n)            : Next probable prime after n
P(n)            : Unrestricted Partition Number (number of decompositions of n 
                  into sums of integers without regard to order)
Pi(n)           : Number of primes <= n
Gcd(m, n)       : Greatest common divisor of m and n.
Modinv(m, n)    : inverse of m modulo n, only valid when gcd(m, n) = 1.
Modpow(m, n, r) : finds m^n modulo r Equivalent to m^n%r but more efficient.
Totient(n)      : finds the number of positive integers less than n which are 
                  relatively prime to n.
IsPrime(n)      : returns zero if n is not probable prime, -1 if it is.
BPSW(n)         : Baillie–PSW primality test. It returns zero if n is composite, 
                  1 for probable prime, 2 for definite prime. 
                  considered to be 100% reliable for numbers up to 10000 digits
APRCL(n)        : Adleman–Pomerance–Rumely primality test. returns zero if n is 
                  composite, 1 for probable prime (only if BPSW used), 2 for 
                  definite prime. WARNING: very slow for large numbers 
                  e.g. 20s for 400 digits
                  If the number is > 6021 digits it reverts to the BPSW test.
NumDivs(n)      : Number of positive divisors of n either prime or composite.
SumDivs(n)      : Sum of positive divisors of n either prime or composite.
NumDigits(n, r) : Number of digits of n in base r.
SumDigits(n, r) : Sum of digits of n in base r.
RevDigits(n, r) : finds the value obtained by writing backwards the digits of n 
                  in base r.
Sqrt(n)         : square root of n
Nroot(n, r)     : rth root of n e.g.r=3 for cube root
NumFact(n)      : number of distinct prime factors of n.
MinFact(n)      : minimum prime factor of n.
MaxFact(n)      : maximum prime factor of n
LLT(n)          : perform Lucas-Lehmer test. Return 0 if 2^n-1 is composite, 
                  1 if prime.
FactConcat(m,n) : Concatenates the prime factors of n (base 10) according to the mode m
                  mode    Order of factors    Repeated factors
                  0       Ascending           No
                  1       Descending          No
                  2       Ascending           Yes
                  3       Descending          Yes
R2(n)           : Number of ways n can be expressed as the sum of x² + y².  
                  (order and sign of x and y are significant)
R3(n)           : Number of ways n can be expressed as the sum of x² + y² + z². 
                  (order and sign of x and y are significant)
LE(a,p)         : Legendre value for (a/p). Only defined if p is an odd prime.
JA(a,p)         : Jacobi value for (a/p). The result is zero when a is a multiple 
                  of p, otherwise it is one if there is a solution of x² = a (mod p) 
                  and it is -1 when the congruence has no solution. 
                  Extension of Legendre to all odd values of p.
KR(a,p)         : Kronecker value for (a/p); an extension of the Jacobi value to
                  all values of p
ISPOW(n)        : returns -1 if n is a perfect power, otherwise 0

[OTHER]
other commands: 
X    : hexadecimal o/p, 
D    : decimal o/p
F n  : control factorisation, 
       0 = just evaluate expression, no factorisation
       1 = evaluate expression, factorise resulting value, but don't do no. of
       divisors, etc.
       2 = evaluate expression, factorise resulting value, then get no of divisors,
           sum of divisors, totient, möbius, sum of squares.
           initial setting is F = 2.
S    : switch to Spanish, 
E    : switch to English
V n  : Set 'verbosity' to n. n=0 is the default which minimises output.
       n = 1 turns on many messages that show more of what is happening internally.
       n = 2 turns on even more messages.
PRINT  Print the names and values of any user variables.
HELP (this command)
EXIT

[YAFU]
The YAFU command controls factorisation using YAFU:

   YAFU ON   Turns on factorisation using YAFU (and turns Msieve off)
   YAFU OFF  Turns off factorisation using YAFU (revert to built-in ECM and SIQS)
   YAFU PATH Displays or changes path used when starting YAFU
   YAFU LOG  Displays path & file name for YAFU output file
   YAFU PLAN <name> 
             where <name> is NONE, NOECM, LIGHT, NORMAL, or DEEP.
             These correspond to the -plan options documented in YAFU's
             docfile.txt file. The default is NORMAL. This is a convenient way
             to control the amount of testing using ECM before switching to SIQS 
             or NFS.

YAFU is on by default but can be turned off by the "YAFU OFF" command and turned 
back on by the YAFU ON command (which also turns Msieve off). The default path to 
access YAFU is hard coded in yafu.cpp and should be changed to whatever is appropriate.

The command YAFU PATH will display the current path and verify that the yafu-X64.exe 
file exists.
The command YAFU PATH SET will display a windows explorer style window where 
you can navigate to the correct folder then click on the yafu exe file. The new path 
to the YAFU file will then be saved in the BigIntCalculator.ini file.

The command YAFU INI will check whether the YAFU.ini file exist. If it does it is
read and any ggnfs_dir parameter is found. If ggnfs_dir is found the path that it 
contains is checked by checking for the existence of the gnfs-lasieve4iXXe.exe files,
where XX is between 11 and 16. Note that YAFU INI requires the YAFU path to already 
be set correctly (by YAFU PATH or otherwise).

The command YAFU INI I allows the ggnfs_dir parameter to be altered or created. It
will display a windows explorer style window where you can navigate to the correct 
folder then click on any file. The new path to the ggnfs files will then be saved
in the ggnfs_dir parameter of the YAFU.ini file.

[MSIEVE]
Msieve is off by default but can be turned on by the "MSIEVE ON" command (which 
also turns YAFU off) and turned back off by the MSIEVE OFF command. The path to 
access msieve should be changed to whatever is appropriate.

MSIEVE PATH will display the current path and verify that the msieve.exe 
file exists.
MSIEVE PATH SET will display a windows explorer style window where you can 
navigate to the correct folder then click on the Msieve exe file. The new path 
to the Msieve file will then be saved in the BigIntCalculator.ini file.

MSIEVE E ON turns on the E option in Msieve for 'deep' ECM
MSIEVE E off turns off the E option

MSIEVE N ON turns on the N option to use the Number Field sieve for factorisation.
MSIEVE N OFF turns off the N option.

[TEST]
There are a number of built-in test commands. In all tests the results are
checked for correctness and a summary of the factorisation results is printed
after the tests are completed:

TEST    1st tests most of the calculator functions, then factorises a series of
        numbers. The numbers are chosen to test for various special cases as well
        as normal factorisation. This test is good for regression testing.

TEST2   test factorisation using pseudo-random numbers of a specified size.
        Command format is TEST2 [num1[,num[,num3]]] where num1 is the number of 
        tests,  num2 is the size of the numbers to be factored in bits. If num3  
        NE 0 the number to be factored consists of 2 approximately same-sized 
        'strong' prime factors, otherwise it is a random number that can contain 
        any number of factors. If the values for num2 and num3 are the same in 
        two TEST2 commands the same sequence of numbers to be factored is 
        generated. This command is useful for benchmarking factorisation.

TEST3   Tests for the built-in bigintegers. These are based on DA's biginteger 
        functions but made into a C++ class with arithmetic , shift, compare 
        operators, etc implemented. However the built-in bigintegers are now 
        only used in the the built-in ECM & SIQS, which themselves are only 
        used for numbers up to 59 digits, so this test is not normally included.

TEST4   test factorisation of mersenne numbers. See https://en.wikipedia.org/wiki/Mersenne_prime
        this test will take over an hour.

TEST5   tests using only YAFU for factorisation. Note that these tests bypass the
        trial division etc normally used and rely on YAFU for all the factorisation.

TEST6   tests using only Msieve for factorisation. Factorise selected Mersenne numbers.

TEST7   tests the Lucas-Lehmer function. Format is TEST7 [num]. All primes <= num are
        tested to see whether 2^p-1 is prime or not. The default value for num is
        12000.   Sample output:

            test7 87000
            18:47:15 2^2 -1 is prime ***
            18:47:15 2^3 -1 is prime ***
            18:47:15 2^5 -1 is prime ***
            18:47:15 2^7 -1 is prime ***
            18:47:15 2^13 -1 is prime ***
            18:47:15 2^17 -1 is prime ***
            18:47:15 2^19 -1 is prime ***
            18:47:15 2^31 -1 is prime ***
            18:47:15 2^61 -1 is prime ***
            18:47:15 2^89 -1 is prime ***
            18:47:15 2^107 -1 is prime ***
            18:47:15 2^127 -1 is prime ***
            18:47:15 2^521 -1 is prime ***
            18:47:15 2^607 -1 is prime ***
            18:47:16 2^1279 -1 is prime ***
            18:47:16 2^2203 -1 is prime ***
            18:47:16 2^2281 -1 is prime ***
            18:47:17 2^3217 -1 is prime ***
            18:47:18 2^4253 -1 is prime ***
            18:47:18 2^4423 -1 is prime ***
            18:47:53 2^9689 -1 is prime ***
            18:47:56 2^9941 -1 is prime ***
            18:48:15 2^11213 -1 is prime ***
            18:55:42 2^19937 -1 is prime ***
            18:57:54 2^21701 -1 is prime ***
            19:00:14 2^23209 -1 is prime ***
            20:33:19 2^44497 -1 is prime ***
            08:18:34 2^86243 -1 is prime ***
            Found 28 Mersenne primes  out of 8450 numbers tested
            2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 
            3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
            0.33% primes found by llt
            99.67% composites found by llt
            08:40:38 test 7 completed time used =  13h 53 min 23.314sec

        This has found the 1st 28 Mersenne primes in less than 14 hours. The 
        last of these was originally found in 1982 using a mult-million $ Cray
        supercomputer. Talk about standing on the shoulders of giants!

Test example:

enter expression to be processed, or HELP, or EXIT
TEST2 5
Use default 48 for number size in bits
 
 <******** output from indivdial tests omitted *****************>

10:48:34 All tests completed. Time used = 0.172 seconds
Test Num Size   time      Unique Factors Total Factors     2nd Fac
   1       14  0:00:00.01             4          4            4
   2       15  0:00:00.04             4          4            3
   3       15  0:00:00.03             3          3            5
   4       15  0:00:00.03             2          2            5
   5       14  0:00:00.02             5          6            4


   note: The 'Size' column gives the size in decimal digits of the number to be
   factored. The '2nd Fac' column gives the size of the 2nd largest factor, 
   which correlates much more closely with time required than the 'Size' does.
   The 'time' column gives the time required for each factorisation to one-
   hundredth of a second.

[AYUDA]
Puedes ingresar expresiones que usen los siguientes operadores y paréntesis:
^ o ** para exponenciación(el exponente debe ser mayor o igual que cero).
* para multiplicación
/ para división entera
% para el resto de la división entera
+ para suma
- para resta
SHL o <<: Desplazar a la izquierda la cantidad de bits indicada en el operando derecho.
SHR o >>: Desplazar a la derecha la cantidad de bits indicada en el operando derecho.
<, ==, >, <=, >=, != para comparaciones.Los operadores devuelven cero si es falso 
        y - 1 si es verdadero.
AND, OR, XOR, NOT para lógica binaria.
n!   : factorial(n debe ser mayor o igual que cero).
p#   : primorial(producto de todos los primos menores o iguales a p).
B(n) : Número probablemente primo anterior a n
F(n) : Número de Fibonacci Fn
L(n) : Número de Lucas Ln = F(n-1) + F(n+1)
N(n) : Número probablemente primo posterior a n
P(n) : particiones irrestrictas(cantidad de descomposiciones de n en sumas de números 
       enteros sin tener en cuenta e orden).
Gcd(m, n)       : Máximo común divisor de estos dos números enteros.
Modinv(m, n)    : inverso de m modulo n, sólo válido cuando gcd(m, n) = 1.
Modpow(m, n, r) : halla m^n módulo r.
Totient(n)      : cantidad de enteros positivos menores que n coprimos con n.
Ja(m,n)         : obtiene el símbolo de Jacobi de m y n. Cuando el segundo argumento
                  es primo, el resultado es cero si m es múltiplo de n, es uno si hay
                  una solución a x² = m (mód n) y es igual a -1 cuando la congruencia
                  mencionada no tiene soluciones.
IsPrime(n)      : returna cero si n no es un primo probable y - 1 si lo es.
NumDivs(n)      : cantidad de divisores positivos de n primos o compuestos.
SumDivs(n)      : suma de divisores positivos de n primos o compuestos.
NumDigits(n, r) : cantidad de dígitos de n en base r.
SumDigits(n, r) : suma de dígitos de n en base r.
RevDigits(n, r) : halla el valor que se obtiene escribiendo para atrás los dígitos 
                  de n en base r.
Sqrt(n)         : parte entera de la raíz cuadrada del argumento
NumFact(n)      : cantidad de factores primos distintos de n. Ejemplo: NumFact(28) = 2 
                  porque los factores primos son 2 y 7
MinFact(n)      : mínimo factor primo de n. Ejemplo: MinFact(28) = 2 porque los 
                  factores primos son 2 y 7.
MaxFact(n)      : máximo factor primo de n. Ejemplo: MaxFact(28) = 7 porque los 
                  factores primos son 2 y 7.

[BACKGROUND]
INTRODUCTION

This is a calculator and factorisation program based on Dario Alpert's program.
See https://www.alpertron.com.ar/ECM.HTM

It factorises numbers or numeric expressions using fast algorithms ECM and SIQS.
ECM = Lenstra elliptic-curve factorization
see https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization
SIQS = Self-initializing quadratic sieve
see http://www.mersennewiki.org/index.php/Self-Initializing_Quadratic_Sieve
or https://en.wikipedia.org/wiki/Quadratic_sieve

HISTORY

the program was converted from browser-based to a console window. The advantage
is that it is somewhat faster, and the calculator part has been carefully tested.
The disadvantage is that you have to download and build it. In order to do that
you need GMP or MPIR multi-precision library and the Boost multi-precision library.

the following changes were made:

C++ rather than C

The calculator part was extensively rewritten to use GMP/MPIR extended precision
and the Boost multiprecision library. Wherever possible GMP functions were used
instead of DAs version of bigIntegers.

Standard arithmetic operators for extended precision values use the Boost library,  
which implements them using GMP/MPIR functions.

FACTORIZATION

The built-in factoriser is essentially DAs program, with an interface function 
that converts GMP/MPIR extended precision numbers to DAs BigIntegers and vice 
versa. The progress messages it produces have been modified to work with a 
console window instead of a Web Browser.

A feature was added to allow use of Msieve as an alternative to the original ECM & SIQS
factorisation. My conclusion was that for larger numbers (> about 60 digits) Msieve
is usually significantly faster, provided that the -e option is used with Msieve.
The -e option causes greater use of ECM within Msieve. The default in mseive is 
to use ECM only for factors < 15 digits. 

Msieve is off by default but can be turned on by the "MSIEVE ON" command (which 
also turns YAFU off) and turned back off by the MSIEVE OFF command. The path to 
access msieve should be changed to whatever is appropriate.

Additionally, the option to use YAFU (Yet Another Factorisation Utility) instead of 
Msieve or the built-in ECM and SIQS has been added. The conclusion is that for 
numbers over about 60 digits YAFU is generally significantly faster than Msieve 
but for larger numbers > about 95 digits it relies on ggnfs.

YAFU is on by default but can be turned off by the "YAFU OFF" command and turned 
back on by the YAFU ON command (which also turns Msieve off). The default path to 
access YAFU should be changed to whatever is appropriate.

As mentioned above ECM and SIQS are used for factorisation.

At all stages a factor list is maintained that contains all known factors, whether
prime or not, that have not yet been split into smaller factors. Initially the
factor list just contains the number to be factorised. Whenever a new factor is found,
existing factors that are multiples of that factor are split into two factors. If
this process creates equal factors they are merged. 

Step 1: if number to factor is > than the the square of the largest prime to be 
used in trial division, check if the number is a perfect power +/- 1 and if so 
attempt to factorise it. This step may return factors that are not prime factors.

Step 2: Try to factorise each factor (there may already be more than 1) by trial division 
using a list of primes. If a factor is found that is: 
    less than the cube of the largest prime in the trial division list, 
    and has no factors in the list, 
    and the factor is not prime 
then the factor can only have two prime factors. In this case factorise it using 
Pollard's Rho algorithm. 

Step 3: For each factor that is not already known to be prime:
A. If the factor is a perfect power replace it with the number which is the root 
   and adjust the the factor's exponent accordingly. Although such numbers are  
   rare this is necessary because SIQS and ECM do not work for numbers which are
   perfect powers.
B. Test whether the number is prime: 
   If it is a Carmichael number factorise it using a specific algorithm. 
   If it is prime mark it as such. 
   Otherwise either:
      factorise it using built-in ECM, SIQS and Lehman algorithms. This method is 
      alway used for numbers less than 2^192 (58 digits). built-in SIQS is only 
      used for numbers between 30 and 95 digits.
  OR
      factorise it using Msieve. Using modified Msieve that makes more use of
      elliptic curve factorisation than the standard version (even with the e option)
      does, this is nearly always faster for larger numbers that would use SIQS 
      for factorisation.
   OR
      factorise it using YAFU
 
sample timing:
2^311-1 (94 digits)
YAFU on             10 min 
MSIEVE on           5 min
builtin ECM & SIQS 57 min
[LOOP]
Simple lists of expressions can be executed repeatedly using the REPEAT n
command e.g.
$p=n($p)
REPEAT 1000

will generate 1000 primes. (If $p has no value assigned initially it defaults 
to 0). Obviously REPEAT is pointless unless some variable used in the loop
is assigned a new value within the loop.

The LOOP command is used if some initial expressions are not to be repeated
e.g.

$p=151
LOOP
$p=n($p)
REPEAT 1000

An alternative to the simple REPEAT is the IF command e.g.
$p=151
LOOP
$p=n($p)
IF ($p < 10000) REPEAT

The IF command is processed as follows:
1.  The expression in brackets is evaluated. If the value is not zero the specified
    action is performed, otherwise no action is taken. The action can be REPEAT 
    which goes back to the start of the loop, or STOP which terminates the loop.
    The loop can contain many IF commands.


the LIST command will output all the saved expressions. Expressions entered
before the last LOOP command are not shown.

Note that commands and invalid expressions are not saved, but there is no way to
edit saved expressions. It is only possible to delete them using the LOOP command
and start again.